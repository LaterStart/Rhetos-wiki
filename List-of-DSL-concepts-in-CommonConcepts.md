## Defining data structure
* **Module** `<name>` - Generates C# namespace and database schema, where the rest of the objects are located at.
* **DataStructure** `<Module>.<name>` - Basic concept for any data structure (e.g. Entity, Browse, Computed, ...) which may contain properties. It is usually not used in DSL script.
* **Entity** `<Module>.<name>` - Data generated by user. Creates C# class and database table. Inherits DataStructure concept.

Simple data types:
* **Binary** `<DataStructure> <field name>`
* **Bool** `<DataStructure> <field name>`
* **Date** `<DataStructure> <field name>`
* **DateTime** `<DataStructure> <field name>`
* **Decimal** `<DataStructure> <field name>`
* **Guid** `<DataStructure> <field name>`
* **Integer** `<DataStructure> <field name>`
* **Money** `<DataStructure> <field name>`
* **ShortString** `<DataStructure> <field name>` - 256 characters max.
* **LongString** `<DataStructure> <field name>` - unlimited length.

Complex data types:
* **Reference** `<DataStructure>.<field name> <referenced data structure>` - Lookup field. Used as type of referenced class in the object model. Represents database FK, having "ID" sufix appended at the column name.
  * **Reference** `<DataStructure>.<field name>` - Simplified syntax in case when the field name is same as the name of the referenced entity.
* **Currency** `<DataStructure>.<field name> <DateQuery> <BankQuery> <RateTypeQuer>` - Complex field containing following data: amount in foreign currency, currency code, amount in local currency and rate.

**Property** means basic concept which is inherited by all abovementioned simple and complex data types, which can be used as any data field.

More concepts:
* **Detail** `<Reference>` - Marks entity as detail of the referenced entity and sets CascadeDelete and SqlIndex.
* **Extends** `<Extension DataStructure>.<base DataStructure>` - Marks first data structure as extension of base data structure. Usually used to extend entity with additional calculated data or to extend legacy entities with the data generated by user. Concept means that extension has the same primary key (ID) value as base records. Extension has to return one record by every base data record.
* **Browse** `<Module>.<name> <original data structure>` - Data structure used to read certain data fields from original data structure. Old name is "SnowFlake".
  * **Take** `<Browse> <field name or references path>` - Creates property on the browse data structure using field name of the original data structure. Beside field naming it can be set by reference path, separated by dot too.
    * Path must be within the quotation marks.
    * If the paths is set, field name will be autimatically generated connecting the field from the path (e.g. Take 'Parent.Class.Name'; => ShortString ParentClassName).
    * Beside reference, as path is it possible to use Base (navigation from extension to base class), `Extends_<Extension name>` (navigation from base to extension) and ID (as Guid property).
    * Browse structure can have Reference field (npr. Take Parent), which gets Guid ID from the referenced structure (ParentID) and navigation property (Parent). It recommended to use just Guid field (e.g. Take 'Parent.ID';) instead.
  * **Take** `<Browse> <field name> '<reference path>'` - Explicitly sets name of created field at the browse structure.
  * **From** `<Browse Property> <field name or reference path>` - Possible to use referenced data, extended data or base structure data.
    * It is recommended to use Take concept instead From because of simplicity.
* **LegacyEntity** `<Module>.<name> <table> <view>` - Data structure which reads data from the view, used to integrate old entities from existing systems (e.g. Imperios VB6, Centrix, ...) inside Rhetos. Table is used so other Rhetos entities could reference LegacyEntity. Table has to have uniqueidentifier ID field with default newid() and unique index. LegacyEntity is writeable from Rhetos. If the view is not updateable, it is possible to add instead-of triggers for storing using SqlTrigger.
  * **LegacyEntity** `<Module>.<name> <table>` - Creates view with entity name and according instead-of triggers for data recording.
  * **LegacyProperty**
  * **LegacyPropertyReadOnly**
* **LinkedItems**
* **Implements** `<DataStructure>.<interface type>` - Implementing given interface on the object model data structure.
* **PropertyFrom** `<destination DataStructure> <source Property>` - Copies field from another data structure. Transfering related Required and SqlIndex concepts.
* **AllPropertiesFrom** `<destination DataStructure> <source DataStructure>` - Copies all fields from another data structure as PropertyFrom. Transfering related Extends concept.
* **AllPropertiesWithCascadeDeleteFrom** `<destination DataStructure> <source DataStructure>` - Copies all fields from another data structure as AllPropertiesFrom. Transfers related CascadeDelete concepts (npr. Detail). 
* **LookupVisible** `<Property>` - Sets given property as default browse structure for entity lookup (name of browse struxture is "`<EntityName>`Lookup"). If default browse structure is not existent, it will be created. LookupVisible can be used on the reference, which in that case adds Guid to the browse structure and on all LookupVisible fields from the referenced entity. Default browse can be still added manually together with the rest of the fields.
  * **REMARK:** This concept is implemented inside OmegaCommonConcepts package. It is required to include that package during deployment.
* **Clustered** Created cluster SqlIndex and SqlIndexMultiple.
* **Polymorphic** - Defining common interface which implements more entities. Documentation: https://github.com/Rhetos/Rhetos/wiki/Polymorphic-concept

## Simple business logic
* **Reguired** `<Property>` - Required field that has to be filled by user.
* **SystemRequired** `<Property>` - System field which has to be filled by system internally.
* **Unique** - `<Property>` - Two records cannot have same value inside this field.
  * **Unique** `<DataStructure> <Property1> <Property2>`
  * **Unique** `<DataStructure> <Property1> <Property2> <Property3>`
  * **UniqueMultiple** `<DataStructure> <field names sperated by comma>` - One string contains n fields.
* **MaxLength** `<Property>` - Limited string length in ShortString or LongString field. Limits higher range.
* **MinLength** `<Property>` - Limited string length in ShortString or LongString field. Limits lower range.
* **Range** `<PropertyFrom> <PropertyTo>` - Value of the first field has to be less or equal to the second field (fields has to be of the same type).
  * **DateRange** `<PropertyFrom> <PropertyTo>` - Derivation of Range which creates Date Field in case they are not existent.
  * **DateTimeRange** `<PropertyFrom> <PropertyTo>` - Derivation of Range which creates DateTime fields in case they are not existent. 
  * **IntegerRange** `<PropertyFrom> <PRopertyTo>` - Derivation of range which creates Integer fields in case they are not existent.
* **RegExMatch** `<Property>` - Text has to match given regex expression.
* **AutoCode** `<ShortString property>` - Generates integer codes with the given prefix. This concept includes Unique and Index.
  * **AutoCodeForEach** `<ShortString property> <grouping property>` - Generates integer codes with the given prefix, using independent count for each group.
* **Logging** `<entity>` - Includes loggin all entity changes. It is required to set the properties from which changes should be tracked.
  * **Log** `<Logging <Property>` - Sets properties which changes are tracked.
  * **AllProperties** `<Logging>` - Enables logging on all properties.
* **CascadeDelete** `<Reference>` - During the delete process, all related entities will be deleted.
* **PesimisticLocking** `<Entity>` - Sets server check during entity recording so the user can save data only if there is no ExclusiveLock on the data record or if the user is owner of the lock. During editing entity detail, it is required only to set the lock to the master entity.
  * To set the lock, client application has to use Common.SetLock and Common.ReleaseLock actions. It also can use those actions on the entities which do not have the PessimisticLocking on but then the conflict protection depends only on check at the client, having risk of some another application not respecting those locks. 
  * Common.SetLock and RleaseLock server actions, accept ResourceType as parameter, (e.g. "Material.Asset") and ResourceID (Guid).
* **CreationTime** `<DateTime property>` - Stores records creation time.
* **ModificationTimeof** `<DateTime property> <Modified property>` - Stores time of the update for the given field at the same entity.
* **Deactivatable** `<Entity>` - Enables deavtivation of the entity:
  * Adds **Bool Active** property which sets the mark if the entity is active or not. Default values are those so the client doesn't have to be aware of that field: During the data recoring, default value is true, while during the update process, default value is the old value.
  * Creates composable filter **ActiveItems** with the optional **ItemID** parameter. Filter returns all active records with the given ID record depending on the status of the entity. Usefull for implementation of lookup.
    * Because of the bug at the new REST Api, while having "filters" as parameter, it is required to specify full filter name (assembly qualified name): "Rhetos.Dom.DefaultConcepts.ActiveItems, Rhetos.Dom.DefaultConcepts.Interfaces".
  * GenericRepository has ability to InsertOrUpdateOrDeleteOrDeactiveate which can be used to deactivate deleted records.
  * **DenyUserEdit** `<Entity>` - Entity with hardcoded data. It is not allowd to make changes using web interface (REST/SOAP).
  * **DenyUserEdit** `<Property>` - Not allowed to edit field values using web interface (REST/SOAP). Remark: It is considered not good practice to combine fields at the same entity, which user can and cannot edit. It is recommended to separate those calculated fields on the entity extension.




